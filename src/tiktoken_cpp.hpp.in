#pragma once

#include <cstdint>
#include <string>
#include <vector>
#include <memory>
#include <stdexcept>

// Forward declarations for tiktoken C API
extern "C" {
    typedef struct TiktokenHandle TiktokenHandle;
    typedef struct TiktokenError TiktokenError;
    
    TiktokenHandle* tiktoken_get_encoding(const char* name, TiktokenError** error);
    void tiktoken_free(TiktokenHandle* handle);
    uint32_t* tiktoken_encode(TiktokenHandle* handle, const char* text, size_t text_len, size_t* count, TiktokenError** error);
    void tiktoken_free_tokens(uint32_t* tokens);
    const char* tiktoken_get_error_message(TiktokenError* error);
    void tiktoken_free_error(TiktokenError* error);
}

namespace tiktoken_cpp {

class EncodingError : public std::runtime_error {
public:
    explicit EncodingError(const std::string& what) : std::runtime_error(what) {}
};

class Encoding {
public:
    Encoding(const std::string& name) {
        TiktokenError* error = nullptr;
        handle_ = tiktoken_get_encoding(name.c_str(), &error);
        
        if (error) {
            std::string error_msg = tiktoken_get_error_message(error);
            tiktoken_free_error(error);
            throw EncodingError("Failed to get encoding: " + error_msg);
        }
        
        if (!handle_) {
            throw EncodingError("Failed to get encoding: Null handle returned");
        }
    }
    
    ~Encoding() {
        if (handle_) {
            tiktoken_free(handle_);
        }
    }
    
    // Disallow copying
    Encoding(const Encoding&) = delete;
    Encoding& operator=(const Encoding&) = delete;
    
    // Allow moving
    Encoding(Encoding&& other) noexcept : handle_(other.handle_) {
        other.handle_ = nullptr;
    }
    
    Encoding& operator=(Encoding&& other) noexcept {
        if (this != &other) {
            if (handle_) {
                tiktoken_free(handle_);
            }
            handle_ = other.handle_;
            other.handle_ = nullptr;
        }
        return *this;
    }
    
    std::vector<uint32_t> encode(const std::string& text) const {
        if (!handle_) {
            throw EncodingError("Encoding handle is null");
        }
        
        TiktokenError* error = nullptr;
        size_t count = 0;
        uint32_t* tokens = tiktoken_encode(handle_, text.c_str(), text.length(), &count, &error);
        
        if (error) {
            std::string error_msg = tiktoken_get_error_message(error);
            tiktoken_free_error(error);
            throw EncodingError("Failed to encode text: " + error_msg);
        }
        
        if (!tokens && count > 0) {
            throw EncodingError("Failed to encode text: Null tokens returned");
        }
        
        std::vector<uint32_t> result(tokens, tokens + count);
        tiktoken_free_tokens(tokens);
        
        return result;
    }
    
private:
    TiktokenHandle* handle_;
};

// Factory functions for each encoding
inline Encoding cl100k_base() {
    return Encoding("cl100k_base");
}

inline Encoding p50k_base() {
    return Encoding("p50k_base");
}

inline Encoding p50k_edit() {
    return Encoding("p50k_edit");
}

inline Encoding r50k_base() {
    return Encoding("r50k_base");
}

inline Encoding o200k_base() {
    return Encoding("o200k_base");
}

} // namespace tiktoken_cpp 